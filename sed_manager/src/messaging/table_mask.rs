use super::uid::TableUID;

#[allow(non_camel_case_types)]
#[repr(u32)]
enum TableIndex {
    Table,
    SPInfo,
    SPTemplates,
    Column,
    Type,
    MethodID,
    AccessControl,
    ACE,
    Authority,
    Certificates,
    C_PIN,
    C_RSA_1024,
    C_RSA_2048,
    C_AES_128,
    C_AES_256,
    C_EC_160,
    C_EC_192,
    C_EC_224,
    C_EC_256,
    C_EC_384,
    C_EC_521,
    C_EC_163,
    C_EC_233,
    C_EC_283,
    C_HMAC_160,
    C_HMAC_256,
    C_HMAC_384,
    C_HMAC_512,
    SecretProtect,
    TPerInfo,
    CryptoSuite,
    Template,
    SP,
    ClockTime,
    H_SHA_1,
    H_SHA_256,
    H_SHA_384,
    H_SHA_512,
    Log,
    LogList,
    LockingInfo,
    Locking,
    MBRControl,
    MBR,
    K_AES_128,
    K_AES_256,
}

pub const fn table_mask(table: TableUID) -> u64 {
    match table.as_u64() >> 32 {
        0x0000_0001 => 1u64 << (TableIndex::Table as u32),
        0x0000_0002 => 1u64 << (TableIndex::SPInfo as u32),
        0x0000_0003 => 1u64 << (TableIndex::SPTemplates as u32),
        0x0000_0004 => 1u64 << (TableIndex::Column as u32),
        0x0000_0005 => 1u64 << (TableIndex::Type as u32),
        0x0000_0006 => 1u64 << (TableIndex::MethodID as u32),
        0x0000_0007 => 1u64 << (TableIndex::AccessControl as u32),
        0x0000_0008 => 1u64 << (TableIndex::ACE as u32),
        0x0000_0009 => 1u64 << (TableIndex::Authority as u32),
        0x0000_000A => 1u64 << (TableIndex::Certificates as u32),
        0x0000_000B => 1u64 << (TableIndex::C_PIN as u32),
        0x0000_000C => 1u64 << (TableIndex::C_RSA_1024 as u32),
        0x0000_000D => 1u64 << (TableIndex::C_RSA_2048 as u32),
        0x0000_000E => 1u64 << (TableIndex::C_AES_128 as u32),
        0x0000_000F => 1u64 << (TableIndex::C_AES_256 as u32),
        0x0000_0010 => 1u64 << (TableIndex::C_EC_160 as u32),
        0x0000_0011 => 1u64 << (TableIndex::C_EC_192 as u32),
        0x0000_0012 => 1u64 << (TableIndex::C_EC_224 as u32),
        0x0000_0013 => 1u64 << (TableIndex::C_EC_256 as u32),
        0x0000_0014 => 1u64 << (TableIndex::C_EC_384 as u32),
        0x0000_0015 => 1u64 << (TableIndex::C_EC_521 as u32),
        0x0000_0016 => 1u64 << (TableIndex::C_EC_163 as u32),
        0x0000_0017 => 1u64 << (TableIndex::C_EC_233 as u32),
        0x0000_0018 => 1u64 << (TableIndex::C_EC_283 as u32),
        0x0000_0019 => 1u64 << (TableIndex::C_HMAC_160 as u32),
        0x0000_001A => 1u64 << (TableIndex::C_HMAC_256 as u32),
        0x0000_001B => 1u64 << (TableIndex::C_HMAC_384 as u32),
        0x0000_001C => 1u64 << (TableIndex::C_HMAC_512 as u32),
        0x0000_001D => 1u64 << (TableIndex::SecretProtect as u32),
        0x0000_0201 => 1u64 << (TableIndex::TPerInfo as u32),
        0x0000_0203 => 1u64 << (TableIndex::CryptoSuite as u32),
        0x0000_0204 => 1u64 << (TableIndex::Template as u32),
        0x0000_0205 => 1u64 << (TableIndex::SP as u32),
        0x0000_0401 => 1u64 << (TableIndex::ClockTime as u32),
        0x0000_0601 => 1u64 << (TableIndex::H_SHA_1 as u32),
        0x0000_0602 => 1u64 << (TableIndex::H_SHA_256 as u32),
        0x0000_0603 => 1u64 << (TableIndex::H_SHA_384 as u32),
        0x0000_0604 => 1u64 << (TableIndex::H_SHA_512 as u32),
        0x0000_0A01 => 1u64 << (TableIndex::Log as u32),
        0x0000_0A02 => 1u64 << (TableIndex::LogList as u32),
        0x0000_0801 => 1u64 << (TableIndex::LockingInfo as u32),
        0x0000_0802 => 1u64 << (TableIndex::Locking as u32),
        0x0000_0803 => 1u64 << (TableIndex::MBRControl as u32),
        0x0000_0804 => 1u64 << (TableIndex::MBR as u32),
        0x0000_0805 => 1u64 << (TableIndex::K_AES_128 as u32),
        0x0000_0806 => 1u64 << (TableIndex::K_AES_256 as u32),
        _ => panic!("please add the table in this list so that it has a mask"),
    }
}

pub const fn is_table_in_mask(table: TableUID, mask: u64) -> bool {
    table_mask(table) & mask != 0
}
